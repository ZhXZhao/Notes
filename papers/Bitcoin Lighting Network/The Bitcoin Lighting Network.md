<!--
 * @Author: ZhXZhao
 * @Date: 2020-02-25 21:52:49
 * @LastEditors: ZhXZhao
 * @LastEditTime: 2020-02-29 16:38:28
 * @Description: 
 -->
# The Bitcoin Lighting Network: Scalable Off-Chain Instant Payments

---



## 写在前面

这篇文章有点长（59页），而且句式有点难懂，需要慢慢啃。

## 比特币区块链的可扩展性问题

比特币限定每个区块大小在1MB以内，每个交易大约250个字节，所以每个区块最多容纳4000个交易。比特币又限定区块平均每10分钟产生一个，所以比特币网络最多每秒只能处理7个交易。

而Visa峰值交易速度能够达到每秒47000个交易。若要是不对比特币的区块大小做限制，比特币达到visa的峰值速度，每个区块的大小接近8G，这就不是普通计算机所能接受的了。要想实现近乎无限速度的小额交易，就要减少广播到比特币区块链上的交易数量。

## 微支付通道网络解决可扩展性问题

两个人之间的日常经常性的交易，就不必让比特币网络中的其他节点知晓这些交易。通过时间锁作为全球共识的一个组成部分可以实现一个高效的去信任结构。

通过使用微支付通道的网络，比特币可以扩大到每天数十亿笔交易，在普通的桌面电脑上也可以运行。

微支付通道在交易的双方建立了一个关系，能够持久地更新余额，延迟向网络广播交易内容。微支付通道的支付是在链下进行通信和交换的。

### 微支付通道不要求可信

微支付通道的双方能够对通道中的余额达成共识是最好的，若有一方提出异议，则网络需要进行判决。
比特币交易中通过将区块链总帐本作为时间戳系统来解决这个问题，那么建立一个类似的系统，不会主动的使用时间戳，而是在必要的时候去使用时间戳在微支付通道中是一个可取的解决方案。

以Alice和Bob为例，双方将一笔比特币提交到一个双重签名地址（只有两个人都签名才能提取资金），Alice和Bob两人也可以随时退回属于自己的那部分资金，这个交易暂时不会被广播到比特币网络上，双方还可持续更新这个通道中的余额。但会遇到一个问题：没有一个时间戳，无法知道通道中的哪笔交易是最后一笔。

所以在微支付通道中设置了**两个状态**：当前余额和任意的旧的弃用的余额。

比特币脚本只会验证通道中的最新的交易，若有一方不守信，将会惩罚他将放在通道中的所有的资金都转移给另一方。如果通道的双方都同意当前通道中的余额状态，真实的余额状态将会更新为当前的余额状态。

只有交易的双方有不诚实的行为时，才会启动链上共识。

### 通道网络

比特币的可扩展性可以通过建立一个大的微支付通道网络来实现。

通过利用hashlock和timelock阻碍比特币的交易输出，通道的另一方将无法直接窃取资金。

在通道网络中，还可以通过多个节点转发资金到目的地，而无需担心资金被窃取。

## 双向支付通道

把多个微支付通道串联起来，创建交易的路由网络，可以使用类似BGP的协议来进行路由。输出脚本由接收者提供的哈希值所阻塞，通过公开一个字符串，使得这个字符串经过哈希后与已知的哈希值匹配，则可以把钱转给接收者。

### 通道创建中的责任问题

一个人为了参与进支付网络，那么他必须要同网络中的其他参与者创建一个微支付通道。

#### 创建无签名的*资金交易（Funding Transaction）*

最初的通道交易由一个人或交易的双方注入资金所创建。创建交易的输入和输出，但不签署交易。

资金交易的输出是一个2of2的多重签名脚本，需要的签名是交易的双方，以下称为Alice和Bob。交易的双方需要告诉对方哪些是用来交易的输入（也就是说，要把预留在通道中的保证金和用于交易的输入的资金区分开来）。当Alice和Bob都同意从交易中提取资金时，需要两个人的共同签名。

#### 来自未签名交易的消费

比特币网络使用的是SIGHASH_NOINPUT交易，用软分叉来实现，确保了交易可以在没有被广播到网络上之前、没有双方签名之前就完成。交易需要在没有新的sighash flags的情况下进行签名，才可以获得交易ID。

如果没有SIGHASH_NOINPUT，不可能从没有交换签名的交易中生成花费，因为花费Funding Transaction要求一个交易的ID作为子输入中签名的一部分。交易ID的一个组成部分是父签名（或者是Funding Transaction的签名），所以双方需要先交换父签名，子交易才可以进行。

SIGHASH_NOINPUT在允许子交易在不签署输入的情况下而执行，从而解决了这个问题。

SIGHASH_NOINPUT的操作顺序：
1. 创建父交易（Funding Transaction）
2. 创建子交易（承诺交易和从承诺交易中的所有花费）
3. 签名子交易
4. 交换子交易的签名
5. 签名父交易
6. 交换父交易的签名
7. 广播父交易到区块链上

#### 承诺交易：不可执行的结构

无签名的Funding Transaction创建后，双方签署并交换初始的承诺交易。承诺交易的花费来自于Funding Transaction，然而只有Funding Transaction被广播到区块链上。

#### 承诺交易：归结责任

因为任何签署的承诺交易都可以被广播到区块链上，而只有一个承诺交易可以被广播，所以必须要防止旧的承诺交易被广播。

所以设立了一个合同，条款为：双方承诺只广播最近的交易，任何广播了旧的交易的一方会违反合同，作为惩罚，将把通道中的所有资金都转给给另一方。

### 创建可撤销合同的通道

为了能够真正地执行合同，构建一个一方可以撤回交易的承诺交易是有必要的。通过使用交易进入区块链的时间和交易的成熟度来确定验证路径，可以实现这种撤销。

### 序列数成熟度

可撤销的序列成熟度合同（RSMC）内容：
1. 所有参与者都向合同中支付一定数额的款项，以执行本合同。
2. 双方可能同意将资金发送到某个合同，但有一定的等待期（示例脚本中为1000个确认），这是可撤销的输出平衡。
3. 一方或双方可以选择在某个日期之前不广播交易；等待期过后，任意一方也可以随时赎回资金。
4. 如果双方都没有广播这笔交易或赎回资金，那么只有在双方都同意在替代交易的支出中加入新的支出时，他们才可以撤销上述支出。在合同广播到区块链后，新的交易支出可以立即赎回。
5. 若合同被广播到区块链，新的支付没有被赎回，那么任意一方都可以赎回之前撤销的支付。

### 哈希的带时间锁的合约（HTLC）

内容：
1. 如果Bob能够在三天之内，向Alice提供一个已知的哈希值H所对应的未知的20字节的随机输入数据R，那么Alice就会结算合同，向Bob支付0.1BTC。
2. 如果三天过去了，那么上述条款无效，结算过程也无效，双方三天后都不能结算和要求付款。
3. 只要本合同双方当事人同意，任何一方都可以(也应该)按照本合同的条款以任何方式选择并提前终止本合同。
4. 违反上述条款，将会罚没该合同内拥有的所有资金给没有违反的另一方，作为另一方的守信奖励。

HTLC是在具有独特脚本的承诺交易中的一个额外的输出：

```
OP_IF
    OP_HASH160 <HASH160(R)> OP_EQUALVERIFY
    2 <Alice2> <Bob2> OP_CHECKMULTISIG
OP_ELSE
    2 <Alice1> <Bob1> OP_CHECKMULTISIG
OP_ENDIF
```

## 密钥存储

使用BIP0032分层确定性钱包生成密钥，密钥是双方预先生成的。在Merkle树中生成。

这样在交换密钥的时候，只需要保存主密钥即可，而不用保存派生出的子密钥，节省了存储开销。
