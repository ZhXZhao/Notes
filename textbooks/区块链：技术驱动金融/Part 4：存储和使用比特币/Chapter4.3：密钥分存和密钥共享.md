<!--
 * @Author: ZhXZhao
 * @Date: 2020-02-10 16:12:19
 * @LastEditors  : ZhXZhao
 * @LastEditTime : 2020-02-10 16:49:47
 * @Description: 
 -->
# 密钥分存和密钥共享

---

- [密钥分存和密钥共享](#%e5%af%86%e9%92%a5%e5%88%86%e5%ad%98%e5%92%8c%e5%af%86%e9%92%a5%e5%85%b1%e4%ba%ab)
  - [密钥分存](#%e5%af%86%e9%92%a5%e5%88%86%e5%ad%98)
  - [门限密码](#%e9%97%a8%e9%99%90%e5%af%86%e7%a0%81)
  - [多重签名](#%e5%a4%9a%e9%87%8d%e7%ad%be%e5%90%8d)


## 密钥分存

密钥分存：密钥被分成N个片段，我们只要获得其中K个片段，就可以把原密钥重新还原，但如果获得的片段数量少于K，就无法知道关于密钥的任何信息。

**naive方法：**
例如，N=2，K=2，意味着我们把想要加密的密钥（原密钥）转换成两个子密钥，只有同时获得这两个子密钥才能拼出原密钥。我们把原密钥称为S，S是一个很大的数字（比如128位）。然后，我们可以随机产生另一个128位的数字R，让R作为其中的一个子密钥，那么另外一个子密钥就是S⊕R，然后，我们把子密钥R和S⊕R保存在两个不同的地方。根据单独子密钥无法知晓原来密钥信息，但同时得到R和S⊕R，就可以通过疑惑运算得到原来的密钥。

但是当N和K不相等的时候，这个方法就行不通了。
**通法：**
例如，N为任意数，K=2，我们找到一个足够大的素数P，S在0到P-1之间。取N个(S+NR) mod P作为子密钥(N=1,2,...,N)，原密钥为S mod P。（可以想象成一条直线，N值为x，模P的值为y，知道直线上的任意两个点，即可以确定直线与y轴交点的纵坐标）。
代数中，直线自由度为1的多项式，因此对于K=2成立。若K=3，则要用抛物线，因为抛物线是自由度为2的多项式。

但密钥分存的方式很少有人采用，因为不太方便。

## 门限密码

**门限签名技术**：如果子密钥储存在不同的设备中，可以以去中心化的方式还原原密钥，而不用在某台设备上完成还原。例如，N=2，K=2，两个子密钥分别保存在手机和电脑上，当在电脑上发起支付请求，电脑会生成一个签名片段发送到手机上，手机会提示支付信息，等待确认，一旦确认，手机会利用它的子密钥完成整个签名，广播到区块链上。若黑客控制了电脑，则可以通过手机上的支付信息来判断出这笔交易有问题，从而不会确认这笔交易。

## 多重签名

**多重签名**：通过比特币脚本，可以直接把一个比特币账户的控制权交给多个密钥，而不是将密钥分存。这些密钥可以保存在不同的地点，并分别生成签名。
