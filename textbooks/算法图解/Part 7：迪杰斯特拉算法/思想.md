<!--
 * @Author: ZhXZhao
 * @Date: 2020-10-30 16:55:21
 * @LastEditors: ZhXZhao
 * @LastEditTime: 2020-10-30 19:28:45
 * @Description:
-->
# 迪杰斯特拉算法思想

迪杰斯特拉算法用于求有向带权图的最短路径。

4步：
1. 从起点开始，首先找出开销最小即可到达的节点。
2. 然后检查该节点的邻居节点，检查是否有前往它们的更短路径，如果有就更新开销。
3. 重复这个过程，直到图中每个节点都这样做了。
4. 计算最终路径。

## 限制
无法处理负权边，如果想处理带负权边的图，则可用贝尔曼-福德(Bellman-Ford)算法。
但是贝尔曼-福德(Bellman-Ford)算法无法处理带有负环路的图。

## 实现
首先需要三个散列表：

一个散列表Graph用来存储图结构，Graph可以为散列表中套散列表。
如起点到A的权重为6，起点到B的权重为2，则可建立散列表如下：
```python
graph = {}
graph["start"] = {}
graph["start"]["A"] = 6
graph["start"]["B"] = 2
```

一个散列表Costs，记录起点到各个节点的开销。
一个散列表Parents，记录每个节点的父节点。
还需要一个数组，用于记录处理过的节点，一个节点只需要处理一次。

过程：
1. 首先初始化图（也就是初始化散列表Graph）、初始化散列表Costs和Parents（从起点到邻居节点）。
2. 在未处理的节点中找出开销最小的节点。
3. 更新其邻居节点的开销。
4. 如果有邻居的开销被更新，同时更新其父节点。
5. 将开销最小的节点标记为处理过的节点。
6. 返回步骤2。

最后Costs中终点对应的值即为最短路径长度，若想获取最短路径上的全部节点，只需从终点开始倒着找Parents中的节点。
